Algorithms with Detailed Design Techniques, Time Complexity & Applications

S.No	Problem	Design Technique (Detailed)	Time Complexity	Applications

1	BFS – Breadth First Search	Level-order exploration of vertices using a queue. Explores all neighbors first before moving deeper. Ideal for shortest unweighted paths.	O(V + E)	Networking, shortest path, social networks, web crawlers
2	DFS – Depth First Search	Recursive or stack-based deep exploration of all nodes along a path before backtracking. Useful in structural analysis of graphs.	O(V + E)	Detecting cycles, solving puzzles, topological sorting
3	Linear Search	Simple brute-force sequential scan checking each element one-by-one without skipping.	O(n)	Searching unsorted lists
4	Binary Search	Divide-and-conquer search on sorted data by repeatedly halving the search space.	O(log n)	Databases, search engines, indexing
5	Merge Sort	Divide-and-conquer sorting: split → sort sublists → merge in sorted order. Stable and consistent.	O(n log n)	Large data sorting, external sorting
6	Quick Sort	Partition-based divide and conquer: choose pivot → partition → sort recursively. Fast average case.	Avg: O(n log n), Worst: O(n²)	General-purpose sorting (used internally in many libraries)
7	Max–Min (Brute Force)	Direct element-by-element comparison checking all values to find min and max.	O(n)	Statistical operations, sensor data analysis
8	Max–Min (Divide & Conquer)	Split array → recursively find min/max → combine results, reducing comparisons.	O(n)	Optimized range analysis
9	0/1 Knapsack (Brute Force)	Explore every possible subset of items (inclusion/exclusion), exponential growth.	O(2ⁿ)	Exact optimal selection when dataset is tiny
10	Fractional Knapsack	Greedy technique selecting items based on value/weight ratio; items can be broken into fractions.	O(n log n)	Resource allocation with divisible goods
11	Prim’s MST	Greedy expansion of a tree by always adding the lowest-weight edge that connects a new vertex.	O(E log V)	Network cabling, electrical grids
12	Kruskal’s MST	Greedy selection of edges sorted by weight, forming MST without cycles (using Union-Find).	O(E log E)	Clustering, minimum wiring
13	Dijkstra’s SSSP	Greedy relaxation choosing the next closest unvisited vertex; uses priority queue for efficiency.	O((V+E) log V)	GPS route finding, traffic navigation
14	Floyd–Warshall APSP	Dynamic programming computes shortest paths between all pairs by incrementally considering intermediate vertices.	O(V³)	Distance matrices, routing tables
15	Travelling Salesman Problem (DP)	Dynamic programming with bitmasking storing shortest paths for subsets of cities (Held–Karp algorithm).	O(n²·2ⁿ)	Logistics, robotics path optimization
16	0/1 Knapsack (DP)	Bottom-up DP tabulation storing optimal value for each weight limit and item subset.	O(nW)	Budgeting, inventory control
17	N-Queens Problem	Backtracking by placing queens row-by-row and undoing invalid placements (pruning).	O(n!)	AI, constraint satisfaction systems
18	Hamiltonian Cycle	Backtracking path exploration checking all permutations while pruning invalid paths.	O(n!)	Route planning, cycle detection
19	M-Coloring Problem	Backtracking assignment of colors to vertices ensuring no two adjacent nodes share a color.	O(mⁿ)	Scheduling, register allocation, puzzle solving

DAA – Programs with Time & Space Complexity
Source: ■filecite■turn3file0■
1. BFS(recursion)
BFS(recursion)
//program
#include<stdio.h>
int a[20][20],q[20],visited[20],n,i,j,f=0,r=-1;
void bfs(int v){
 visited[v]=1;
 printf("%d->",v);
 for(i=1;i<=n;i++){
 if(a[v][i]==1 && visited[i]==0){
 visited[1]=1;
 q[++r]=i;
 }
 }
 if(f>r)
 return ;
 v=q[f++];
 bfs(v);
}
void main(){
 printf("Enter the size:");
 scanf("%d",&n);
 printf("Enter adjacency matrix\n");
 for(int i=1;i<=n;i++){
 visited[i]=0;
 for(int j=1;j<=n;j++){
 scanf("%d",&a[i][j]);
 }
 }
 bfs(1);
 return ;
}
Time: O(V+E)
Space: O(V)
2. DFS(recursion)
DFS(recursion)
//program
#include<stdio.h>
int a[20][20],reach[20],n;
void Dfs(int v){
 reach[v]=1;
 for(int i=1;i<=n;i++){
 if(a[v][i]==1 && reach[i]==0){
 printf("\n %d->%d",v,i);
 Dfs(i);
 }
 }
 return ;
}
void main(){
 int i,j,count=0;
 printf("Enter size of graph: ");
 scanf("%d",&n);
 for(int i=1;i<=n;i++){
 reach[i]=0;
 for(int j=1;j<=n;j++){
 a[i][j]=0;
 }
 }
 printf("Enter the adjacency matrix \n");
 for(int i=1;i<=n;i++){
 for(int j=1;j<=n;j++){
 scanf("%d",&a[i][j]);
 }
 }
 Dfs(1);
 for(int i=1;i<=n;i++){
 if(reach[i]!=0)
 count++;
 }
 if(count==n)
 printf("\nGraph is connected");
 else
 printf("\nNot connected");
 return ;
}
Time: O(V+E)
Space: O(V)
3. Linear Search
Linear Search
//program
#include<stdio.h>
void main(){
 int n;
 printf("Enter size of array: ");
 scanf("%d",&n);
 int a[n],key;
 printf("Enter array: \n");
 for(int i=0;i<n;i++)
 scanf("%d",&a[i]);
 printf("Enter the key to search: ");
 scanf("%d",&key);
 for(int i=0;i<n;i++){
 if(a[i]==key){
 printf("%d found at position %d",n,i+1);
 return ;
 }
 }
 printf("%d not present in array",n);
}
Time: O(n)
Space: O(1)
4. Binary Search(Recursion)
Binary Search(Recursion)
//program
#include<stdio.h>
int binarySearch(int a[],int low,int high,int key){
 if(low>high)
 return -1;
 int mid=(low+high)/2;
 if(a[mid]>key)
 binarySearch(a,low,mid-1,key);
 else if(a[mid]<key)
 binarySearch(a,mid+1,high,key);
 else{
 printf("%d fount at position %d",key,mid+1);
 return mid+1;
 }
}
void main(){
 int n,key;
 printf("Enter size of array: ");
 scanf("%d",&n);
 printf("Enter the sorted array: ");
 int a[n];
 for(int i=0;i<n;i++)
 scanf("%d",&a[i]);
 printf("Enter key to search: ");
 scanf("%d",&key);
 int pos=binarySearch(a,0,n-1,key);
 if(pos==-1)
 printf("%d not found in array",key);
}
Time: O(log n)
Space: O(log n)
5. Merge Sort
Merge Sort
//program
#include <stdio.h>
#include <stdlib.h>
void Merge(int a[], int low, int mid, int high) {
 int i, j, k, temp[high];
 i = low;
 k = low;
 j = mid + 1;
 while (i <= mid && j <= high) {
 if (a[i] < a[j]) {
 temp[k] = a[i];
 k++;
 i++;
 } else {
 temp[k] = a[j];
 k++;
 j++;
 }
 }
 while (i <= mid) {
 temp[k] = a[i];
 k++;
 i++;
 }
 while (j <= high) {
 temp[k] = a[j];
 k++;
 j++;
}
 for (i = low; i <= high; i++) {
 a[i] = temp[i];
 }
}
void MergeSort(int a[], int low, int high) {
 int mid;
 if (low < high) {
 mid = (low + high) / 2;
 MergeSort(a, low, mid);
 MergeSort(a, mid + 1, high);
 Merge(a, low, mid, high);
 }
}
void main() {
 int n, *a, k;
 printf("\n Enter How many Numbers: ");
 scanf("%d", &n);
 a = (int *)calloc(n, sizeof(int));
 printf("\nEnter %d elements:\n", n);
 for (k = 0; k < n; k++) {
 scanf("%d\t", &a[k]);
 }
 MergeSort(a, 0, n - 1);
 printf("\nSorted Numbers are: \n ");
 for (k = 0; k < n; k++) {
 printf("%d\t", a[k]);
 }
}
Time: O(n log n)
Space: O(n)
6. Quick Sort
Quick Sort
//program
#include <stdio.h>
#include <time.h>
int partition(int a[], int low, int high) {
 int pivot = a[low];
 int i = low;
 int j = high;
 while (i < j) {
 while (a[i] <= pivot && i <= high)
 i++;
 while (a[j] > pivot && j >= low)
 j--;
 if (i < j) {
 int temp = a[i];
 a[i] = a[j];
 a[j] = temp;
 }
 }
 int temp = a[low];
 a[low] = a[j];
 a[j] = temp;
 return j;
}
void quicksort(int a[], int low, int high) {
if (low < high) {
 int p = partition(a, low, high);
 quicksort(a, low, p - 1);
 quicksort(a, p + 1, high);
 }
}
int main() {
 int n, i, a[100];
 clock_t start, end;
 double cpu_time_used;
 printf("Enter number of elements: ");
 scanf("%d", &n);
 printf("Enter elements:\n");
 for (i = 0; i < n; i++)
 scanf("%d", &a[i]);
 // start time
 start = clock();
 quicksort(a, 0, n - 1);
 // end time
 end = clock();
 cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
 printf("Sorted array:\n");
 for (i = 0; i < n; i++)
 printf("%d ", a[i]);
 printf("\nTime taken: %f seconds\n", cpu_time_used);
 return 0;
}
Time: Avg O(n log n), Worst O(n²)
Space: O(log n)
7. Min_Max(BF)
Min_Max(BF)
//program
#include<stdio.h>
#include<stdlib.h>
int main(){
 int *a = (int *)malloc(10*sizeof(int));
 printf("Enter the array: ");
 for(int i=0;i<10;i++){
 scanf("%d",a+i);
 }
 int min=a[0],max=a[0];
 for(int i=1;i<10;i++){
 if(min>a[i])
 min=a[i];
 else if(max<a[i])
 max=a[i];
 }
 printf("\nmin=%d\nmax=%d\n",min,max);
 return 0;
}
Time: O(n)
Space: O(1)
8. Min_Max(DandC)
Min_Max(DandC)
//program
#include<stdio.h>
#include<stdlib.h>
int max,min;
int a[100];
void min_max(int i,int j){
 if(i==j){
 min=a[i];max=a[j];
 }
 else{
 if(i==j-1){
 if(a[i]>a[j]){
 min=a[j];
 max=a[i];
 }
 else{
 min=a[i];
 max=a[j];
 }
 }
 else{
 int mid = (i+j)/2;
 min_max(i,mid);
 int min1=min,max1=max;
 min_max(mid+1,j);
 if(min1<min)min=min1;
 if(max1>max)max=max1;
 }
 }
}
void main(){
 int n;
 printf("Enter no.of elements: ");
 scanf("%d",&n);
 printf("Enter the array: ");
 for(int i=0;i<n;i++){
 scanf("%d",&a[i]);
 }
 min=a[0];
 max=a[0];
 min_max(0,n-1);
 printf("\nMin=%d\nMax=%d\n",min,max);
}
Time/Space: Not available
9. KnapSack(BF)
KnapSack(BF)
// Knapsack Problem using Brute Force Approach
#include <stdio.h>
#include <math.h>
int main() {
 int n, i, j, k;
 float Capacity;
 printf("Enter number of items: ");
scanf("%d", &n);
 float p[n], w[n];
 printf("Enter profit and weight of each item:\n");
 for (i = 0; i < n; i++) {
 scanf("%f %f", &p[i], &w[i]);
 }
 printf("Enter knapsack capacity: ");
 scanf("%f", &Capacity);
 int A[n], bestChoice[n];
 for (i = 0; i < n; i++) {
 A[i] = 0;
 bestChoice[i] = 0;
 }
 float bestValue = 0, bestWeight = 0;
 long long combinations = pow(2, n);
 for (i = 1; i < combinations; i++) {
 // generate next binary pattern in A[]
 j = n - 1;
 while (j >= 0 && A[j] == 1) {
 A[j] = 0;
 j--;
 }
 if (j >= 0) A[j] = 1;
 // evaluate this subset
 float tempWeight = 0, tempValue = 0;
 for (k = 0; k < n; k++) {
 if (A[k] == 1) {
 tempWeight += w[k];
 tempValue += p[k];
 }
 }
 // check if best
 if (tempWeight <= Capacity && tempValue > bestValue) {
 bestValue = tempValue;
 bestWeight = tempWeight;
 for (k = 0; k < n; k++)
 bestChoice[k] = A[k];
 }
 }
 // print results
 printf("\nBest solution vector:\n{ ");
 for (i = 0; i < n; i++)
 printf("%d ", bestChoice[i]);
 printf("}\n");
 printf("Total Profit = %.2f\n", bestValue);
 printf("Total Weight = %.2f\n", bestWeight);
 return 0;
}
Time: O(2■)
Space: O(n)
10. KnapSack(Fractional_Greedy)
KnapSack(Fractional_Greedy)
//program
# include<stdio.h>
void knapsack(int n, float weight[], float profit[], float capacity)
{
 float x[20], tp = 0;
 int i, j;
 float u;
 u = capacity;
 for (i = 0; i < n; i++)
 x[i] = 0.0;
 for (i = 0; i < n; i++)
 {
 if (weight[i] > u)
 break;
 else
 {
 x[i] = 1.0;
 tp = tp + profit[i];
 u = u - weight[i];
 }
 }
 if (i < n)
 {
 x[i] =( u / weight[i]);
 tp = tp + (x[i] * profit[i]);
 }
 printf("\nThe result vector is:- ");
 for (i = 0; i < n; i++)
 printf("%f\t", x[i]);
 printf("\nMaximum profit is:- %f", tp);
}
int main()
{
 float weight[20], profit[20], capacity;
 int num, i, j;
 float ratio[20], temp;
 printf("\nEnter the no. of objects:- ");
 scanf("%d", &num);
 printf("\nEnter the weights of %d objects :-",num);
 for (i = 0; i < num; i++)
 scanf("%f", &weight[i]);
 printf("\nEnter the profits of %d objects :-",num);
 for (i = 0; i < num; i++)
 scanf("%f", &profit[i]);
 printf("\nEnter the capacityacity of knapsack:- ");
 scanf("%f", &capacity);
 for (i = 0; i < num; i++)
 ratio[i] = profit[i] / weight[i];
 //sorting profits and weights according to decreasing order of p[i]/w[i] ratio
 for (i = 0; i < num; i++)
 {
 for (j = 0; j < num-i-1; j++)
 {
 if (ratio[j] < ratio[j+1])
 {
 temp = ratio[j];
 ratio[j] = ratio[j+1];
 ratio[j+1] = temp;
 temp = weight[j];
 weight[j] = weight[j+1];
 weight[j+1] = temp;
 temp = profit[j];
 profit[j] = profit[j+1];
 }
 }
 }
 knapsack(num, weight, profit, capacity);
 return 0;
}
Time: O(n log n)
Space: O(1)
11. Prims
Prims
//program
#include <stdio.h>
#define infinity 999
int a, b, u, v, n, i, j, ne = 1;
int visited[10] = {0}, mincost = 0;
int cost[10][10], t[10][2], near[15];
int main()
{
 printf("\nEnter the number of nodes: ");
 scanf("%d", &n);
 printf("\nEnter the adjacency matrix:\n");
 for (i = 1; i <= n; i++)
 {
 for (j = 1; j <= n; j++)
 {
 scanf("%d", &cost[i][j]);
 if (cost[i][j] == 0)
 cost[i][j] = infinity;
 }
 }
 int min = infinity, k = 1, l = 1;
 // ---- Find minimum edge in entire matrix ----
 for (i = 1; i <= n; i++)
 {
 for (j = 1; j <= n; j++)
 {
 if (cost[i][j] < min)
 {
 min = cost[i][j];
 k = i;
 l = j;
 }
 }
 }
 mincost = cost[k][l];
 t[1][1] = k;
 t[1][2] = l;
 for (i = 1; i <= n; i++)
 {
 if (cost[i][l] < cost[i][k])
 near[i] = l;
 else
 near[i] = k;
 }
 near[k] = near[l] = 0;
 int minval = infinity, minj;
 // ---- Prim's algorithm continues ----
 for (i = 2; i <= n - 1; i++)
{
 minval = infinity;
 for (j = 1; j <= n; j++)
 {
 if (near[j] != 0 && cost[j][near[j]] < minval)
 {
 minval = cost[j][near[j]];
 minj = j;
 }
 }
 t[i][1] = minj;
 t[i][2] = near[minj];
 mincost += cost[minj][near[minj]];
 near[minj] = 0;
 for (k = 1; k <= n; k++)
 {
 if (near[k] != 0 &&
 cost[k][near[k]] > cost[k][minj])
 {
 near[k] = minj;
 }
 }
 }
 printf("\nMinimum cost = %d", mincost);
 printf("\nEdges of Minimum Cost Spanning Tree:\n");
 for (i = 1; i <= n - 1; i++)
 {
 printf("%d -- %d\n", t[i][1], t[i][2]);
 }
 return 0;
}
Time: O(n²)
Space: O(n)
12. Krushkal's
Krushkal's
//program
#include <stdio.h>
#define infinity 999
int a[20][20];
int p[20]; // parent array (for union-find)
int ne = 1;
int mincost = 0;
int find(int i)
{
 while (p[i] > 0)
 i = p[i];
 return i;
}
void Union(int i, int j)
{
 if (i != j)
 p[j] = i;
}
int main()

{
 int n, i, j, u, v, v1, v2, cmin;
 printf("Enter number of vertices: ");
 scanf("%d", &n);
 printf("Enter adjacency matrix:\n");
 for (i = 1; i <= n; i++)
 p[i] = -1;
 for (i = 1; i <= n; i++)
 {
 for (j = 1; j <= n; j++)
 {
 scanf("%d", &a[i][j]);
 if (a[i][j] == 0)
 a[i][j] = infinity;
 }
 }
 printf("\nEdges in the Minimum Cost Spanning Tree:\n");
 while (ne < n)
 {
 cmin = infinity;
 // ---- Find minimum cost edge in matrix ----
 for (i = 1; i <= n; i++)
 {
 for (j = 1; j <= n; j++)
 {
 if (a[i][j] < cmin)
 {
 cmin = a[i][j];
 u = i;
 v = j;
 }
 }
 }
 v1 = find(u);
 v2 = find(v);
 if (v1 != v2)
 {
 printf("%d -- %d cost = %d\n", u, v, cmin);
 mincost += cmin;
 Union(v1, v2);
 ne++;
 }
 // remove edge from matrix
 a[u][v] = a[v][u] = infinity;
 }
 printf("\nMinimum cost = %d\n", mincost);
 return 0;
}
Time/Space: Not available
13. Single source shortest path
Single source shortest path
//program
#include <stdio.h>
#define infinity 999

void dijkstra(int n, int v, int cost[10][10]) {
 int i, u, count, w, flag[10], min, dist[10];
 // Initialize
 for (i = 1; i <= n; i++) {
 flag[i] = 0;
 dist[i] = cost[v][i];
 }
 flag[v] = 1; // Mark the starting node as visited
 dist[v] = 0;
 count = 2;
 while (count <= n) {
 min = infinity;
 // Find the next node with the smallest distance
 for (w = 1; w <= n; w++) {
 if (dist[w] < min && !flag[w]) {
 min = dist[w];
 u = w;
 }
 }
 flag[u] = 1;
 count++;
 // Update distances of adjacent vertices
 for (w = 1; w <= n; w++) {
 if ((dist[u] + cost[u][w] < dist[w]) && !flag[w]) {
 dist[w] = dist[u] + cost[u][w];
 }
 }
 }
 // Print the shortest distances
 printf("\nShortest paths from vertex %d:\n", v);
 for (i = 1; i <= n; i++) {
 if (i != v)
 printf("Vertex %d -> %d = %d\n", v, i, dist[i]);
 }
}
int main() {
 int n, v, i, j, cost[10][10];
 printf("Enter the number of vertices: ");
 scanf("%d", &n);
 printf("Enter the cost matrix:\n");
 for (i = 1; i <= n; i++) {
 for (j = 1; j <= n; j++) {
 scanf("%d", &cost[i][j]);
 if (cost[i][j] == 0)
 cost[i][j] = infinity; // No direct edge
 }
 }
 printf("Enter the source vertex: ");
 scanf("%d", &v);
 dijkstra(n, v, cost);
 return 0;
}
Time/Space: Not available
14. All pair shortest path
All pair shortest path
//program
#include<stdio.h>
#define INF 999
int min(int,int);
void floyd(int p[10][10],int n){
 int i,j,k;
 for(k=1;k<=n;k++)
 for(i=1;i<=n;i++)
 for(j=1;j<=n;j++)
 p[i][j]=min(p[i][j],p[i][k]+p[k][j]);
}
int min(int a,int b){
 if(a>b)return b;
 return a;
}
int main(){
 int n,cost[10][10];
 printf("Enter no.of nodes: ");
 scanf("%d",&n);
 printf("\nEnter the cost adjacency matrix of graph\n");
 for(int i=1;i<=n;i++)
 for(int j=1;j<=n;j++)
 scanf("%d",&cost[i][j]);
 printf("\nInput Data:\n");
 for(int i=1;i<=n;i++){
 for(int j=1;j<=n;j++)
 printf("%d ",cost[i][j]);
 printf("\n");
 }
 floyd(cost,n);
 printf("The cost of all pair shortest path :\n");
 for(int i=1;i<=n;i++){
 for(int j=1;j<=n;j++)
 printf("%d ",cost[i][j]);
 printf("\n");
 }
}
Time/Space: Not available
15. TSP(dynamic principle of optimality)
TSP(dynamic principle of optimality)
//program
#include <stdio.h>
int a[10][10], visited[10], n, cost = 0, s;
int least(int city)
{
 int i, next_city = -1;
 int min = 999;
 for (i = 1; i <= n; i++)
 {
 if (a[city][i] != 0 && visited[i] == 0)
 {
 if (a[city][i] < min)
 {
min = a[city][i];
 next_city = i;
 }
 }
 }
 return next_city;
}
void mincost(int city)
{
 int nextCity;
 visited[city] = 1;
 printf("%d --> ", city);
 nextCity = least(city);
 if (nextCity == -1)
 {
 cost += a[city][s]; // return to start
 printf("%d", s);
 return;
 }
 cost += a[city][nextCity];
 mincost(nextCity);
}
int main()
{
 int i, j;
 printf("Enter number of cities: ");
 scanf("%d", &n);
 printf("Enter cost matrix:\n");
 for (i = 1; i <= n; i++)
 {
 for (j = 1; j <= n; j++)
 scanf("%d", &a[i][j]);
 visited[i] = 0;
 }
 printf("Enter starting city: ");
 scanf("%d", &s);
 printf("\nPath:\n");
 mincost(s);
 printf("\n\nMinimum cost = %d\n", cost);
 return 0;
}
Time: O(n²) greedy
Space: O(n)
16. KnapSack(Dynamic tabular method)
KnapSack(Dynamic tabular method)
//program
#include <stdio.h>
int w[10], p[10], n, i, j, cap, x[10] = {0};
int max(int a, int b) {
return (a > b) ? a : b;
}
int main() {
 int profit, value;
 printf("\nEnter the number of items: ");
 scanf("%d", &n);
 printf("Enter profit and weight of each item (in increasing order of weight):\n");
 for (i = 1; i <= n; i++) {
 printf("Item %d: ", i);
 scanf("%d %d", &p[i], &w[i]);
 }
 printf("\nEnter the knapsack capacity: ");
 scanf("%d", &cap);
 int knap[n + 1][cap + 1];
 // DP Table construction
 for (i = 0; i <= n; i++) {
 for (j = 0; j <= cap; j++) {
 if (i == 0 || j == 0)
 knap[i][j] = 0;
 else {
 if (j < w[i])
 value = knap[i - 1][j];
 else
 value = max(knap[i - 1][j], p[i] + knap[i - 1][j - w[i]]);
 knap[i][j] = value;
 }
 }
 }
 profit = knap[n][cap];
 // Backtracking to find selected items
 i = n;
 j = cap;
 while (i > 0 && j > 0) {
 if (knap[i][j] != knap[i - 1][j]) {
 x[i] = 1;
 j -= w[i];
 }
 i--;
 }
 printf("\nSolution vector (selected items): ");
 for (i = 1; i <= n; i++)
 printf("%d ", x[i]);
 printf("\n\nItems included:\n");
 printf("Item\tWeight\tProfit\n");
 for (i = 1; i <= n; i++) {
 if (x[i])
 printf("%d\t%d\t%d\n", i, w[i], p[i]);
 }
 printf("\nTotal Profit = %d\n", profit);
 return 0;
}
Time/Space: Not available
17. NQueens(BackTracking)
NQueens(BackTracking)
//program
#include<stdio.h>
#include<math.h>
#include<stdlib.h>
int x[30],count=0;
int place(int k,int i)
{
int j;
for(j=1;j<k;j++)
{
 if((x[j]==i)||((abs(x[j]-i)==abs(j-k))))
 return 0;
}
return 1;
}
void print_sol(int n)
{
int i,j;
count++;
printf("\n\nSolution#%d:\n",count);
for(i=1;i<=n;i++)
{
 for(j=1;j<=n;j++)
 {
 if(x[i]==j)
 printf("Q\t");
 else
 printf("*\t");
}
printf("\n");
}
}
void queen(int k,int n)
{
int i;
for(i=1;i<=n;i++)
{
 if(place(k,i))
 {
 x[k]=i;
 if(k==n)
 print_sol(n);
 else
 queen(k+1,n);
 }
}
}
void main()
{
int i,n;
printf("Enter the number of Queens\n");
scanf("%d",&n);
queen(1,n);
printf("\nTotal solutions=%d",count);
}
Time: O(n!)
Space: O(n)
18. MColoring(BackTracking)
MColoring(BackTracking)
//program

#include<stdio.h>
int n,m,x[10]={0},a[10][10];
void Nextvalue(int k)
{ int j;
 do
 { x[k]=(x[k]+1)%(m+1);
 if(x[k]==0)
 return;
 for(j=1;j<=n;j++)
 { //if j is adjacent to k and colors of both j and k are same
 if((a[k][j]!=0 && x[k]==x[j]) || (a[j][k]!=0 && x[k]==x[j]))
 break;
 }
 //adjacent vertices of k have different colors from k
 //a new color found
 if(j==n+1)
 return;
 }whi
